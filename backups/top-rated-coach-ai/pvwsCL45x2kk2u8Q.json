{
  "createdAt": "2025-07-11T10:15:21.615Z",
  "updatedAt": "2025-10-24T22:59:10.000Z",
  "id": "pvwsCL45x2kk2u8Q",
  "name": "Add Task Groups based on Audit Types",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "new_audit",
        "authentication": "headerAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "id": "10dd99f8-09e5-49a7-acce-964b536e11c0",
      "name": "Get Unprocessed Audits Real Time",
      "webhookId": "987f4f26-5ff8-4ada-9361-e1becba9c444",
      "credentials": {
        "httpHeaderAuth": {
          "id": "XN2wz67KBUO7399v",
          "name": "Supabase-TopRatedCoach-AuthenticationHeader"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "1c9b4d39-5d80-4c5e-8569-8c4a5beaa71f",
              "leftValue": "={{ $json.body.data.status }}",
              "rightValue": "pending",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        224,
        0
      ],
      "id": "b768f8c8-fa25-4bfa-b41e-10a5564d3d71",
      "name": "Confirm if the Status is Pending of Audit"
    },
    {
      "parameters": {
        "content": "## Add Steps in DB based on Audit Type Selected.\n\nRight now there is only one audit type \"lead_conversion\" which has two steps right now.\n\nOutbound Call Analysis\nInbound Call Analysis\n\n",
        "height": 220,
        "width": 460,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        32,
        -256
      ],
      "typeVersion": 1,
      "id": "6d444f7c-c5f3-40e9-b143-ecb73237e4a3",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "10586252-1ec1-4a1b-83dd-bd5fb536872b",
              "name": "Outbound Call Analysis",
              "value": "Outbound_Call_Analysis",
              "type": "string"
            },
            {
              "id": "56e4f03c-2397-4045-83d9-7e4639e5c46a",
              "name": "Inbound Call Analysis",
              "value": "Inbound_Call_Analysis",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        672,
        0
      ],
      "id": "34e35be5-f4ea-4730-92a7-c6589ba2c0b8",
      "name": "Set Lead Gen Steps Names"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$vars.SupabaseDBUrl}}/task_groups",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $vars.Supabase_Service_Role }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $vars.Supabase_Service_Role }}"
            },
            {
              "name": "Prefer",
              "value": "return=representation,resolution=merge-duplicates"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "=[\n{\n  \"audit_id\": \"{{ $('Get Unprocessed Audits Real Time').item.json.body.data.id }}\",\n    \"business_id\": \"{{ $('Get Unprocessed Audits Real Time').item.json.body.data.business_id }}\",\n    \"task_name\": \"{{ $('Set Lead Gen Steps Names').item.json['Outbound Call Analysis'] }}\",\n    \"scheduled_at\": \"{{ $('Time to Schedule call based on Business Timezone Within 24 hours - Mon - Fri').item.json.scheduled_at }}\",\n    \"status\": \"pending\"\n  },\n{\n  \"audit_id\": \"{{ $('Get Unprocessed Audits Real Time').item.json.body.data.id }}\",\n    \"business_id\": \"{{ $('Get Unprocessed Audits Real Time').item.json.body.data.business_id }}\",\n    \"task_name\": \"{{ $('Set Lead Gen Steps Names').item.json['Inbound Call Analysis'] }}\",\n    \"scheduled_at\": \"{{ $('Time to Schedule Max Limit of Waiting for Inbound Call 5 days from outbound call time').item.json.scheduled_at }}\",\n    \"status\": \"pending\"\n  }\n]",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1344,
        0
      ],
      "id": "7b367c7c-1277-4a0d-a90e-11585d9c7afe",
      "name": "Creating Steps in Task Groups Table"
    },
    {
      "parameters": {
        "url": "={{$vars.SupabaseDBUrl}}/businesses",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "id",
              "value": "=eq.{{ $('Get Unprocessed Audits Real Time').item.json.body.data.business_id }}"
            },
            {
              "name": "select",
              "value": "=*"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{$vars.Supabase_API_Key}}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $vars.Supabase_Service_Role }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        448,
        0
      ],
      "id": "9b79e701-9fa5-486e-b106-99cb5e53df61",
      "name": "Get a specific business"
    },
    {
      "parameters": {
        "jsCode": "function isValidTimeZone(tz) {\n  try {\n    new Intl.DateTimeFormat(undefined, { timeZone: tz });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Helper to get local date/time components from UTC date in given timezone\nfunction getLocalParts(utcDate, tz) {\n  const opts = {\n    timeZone: tz,\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric',\n    second: 'numeric',\n    hourCycle: 'h23',\n  };\n  const formatter = new Intl.DateTimeFormat('en-US', opts);\n  const parts = formatter.formatToParts(utcDate);\n  const map = {};\n  parts.forEach(p => {\n    if (p.type !== 'literal') map[p.type] = parseInt(p.value, 10);\n  });\n  // Add weekday\n  const naiveDate = new Date(map.year, map.month - 1, map.day);\n  map.weekday = naiveDate.getDay(); // 0=Sun, 6=Sat\n  return map;\n}\n\n// Helper to parse offset string like 'GMT-04:00' or 'GMT-4' to milliseconds\nfunction parseOffset(offsetStr) {\n  if (offsetStr === 'GMT' || offsetStr === 'UTC') return 0;\n  const match = offsetStr.match(/^GMT([+-])(\\d{1,2})(?::(\\d{2}))?$/);\n  if (!match) throw new Error(`Invalid offset format: ${offsetStr}`);\n  const sign = match[1] === '+' ? 1 : -1;\n  const hours = parseInt(match[2], 10);\n  const minutes = parseInt(match[3] || 0, 10);\n  return sign * (hours * 3600000 + minutes * 60000);\n}\n\n// Helper to get offset in ms for a given UTC date in timezone\nfunction getOffsetMs(utcDate, tz) {\n  const offsetOpts = {\n    timeZone: tz,\n    timeZoneName: 'shortOffset',\n  };\n  const formatter = new Intl.DateTimeFormat('en-US', offsetOpts);\n  const parts = formatter.formatToParts(utcDate);\n  const offsetPart = parts.find(p => p.type === 'timeZoneName');\n  if (!offsetPart) throw new Error('No timezone name found');\n  return parseOffset(offsetPart.value);\n}\n\n// Helper to create UTC Date from local components in timezone\nfunction localPartsToUtc(parts, tz) {\n  const candidateMs = Date.UTC(\n    parts.year,\n    parts.month - 1,\n    parts.day,\n    parts.hour,\n    parts.minute,\n    parts.second || 0\n  );\n  // Use candidate as approximate UTC to get offset (handles DST)\n  const offsetMs = getOffsetMs(new Date(candidateMs), tz);\n  const utcMs = candidateMs - offsetMs;\n  const utcDate = new Date(utcMs);\n\n  // Optional: Verify (commented out for efficiency, enable if DST issues expected)\n  const verifiedParts = getLocalParts(utcDate, tz);\n  if (verifiedParts.hour !== parts.hour || verifiedParts.minute !== parts.minute ||\n      verifiedParts.day !== parts.day || verifiedParts.month !== parts.month) {\n    // Mismatch due to DST skip/ambiguity - adjust logic here (e.g., add 1 hour)\n    // For now, proceed as-is since working hours rarely hit transitions\n  }\n\n  return utcDate;\n}\n\n// Helper to add days to local date components (handles month/year rollover)\nfunction addDaysToLocal(parts, days) {\n  const naive = new Date(parts.year, parts.month - 1, parts.day + days);\n  return {\n    year: naive.getFullYear(),\n    month: naive.getMonth() + 1,\n    day: naive.getDate(),\n    weekday: naive.getDay(),\n  };\n}\n\nfunction getNextWorkingTimeInTimezone(timeZone) {\n  let tz = timeZone;\n  if (!isValidTimeZone(tz)) {\n    console.warn(`Invalid timezone ${timeZone}, defaulting to America/New_York`);\n    tz = 'America/New_York';\n  }\n\n  const WORK_START_HOUR = 9;\n  const WORK_END_HOUR = 18;\n\n  const nowUtc = new Date();\n  let local = getLocalParts(nowUtc, tz);\n\n  // Minutes since midnight\n  let minutesNow = local.hour * 60 + local.minute;\n\n  const workStartMin = WORK_START_HOUR * 60;\n  const workEndMin = WORK_END_HOUR * 60;\n\n  let targetLocal = { ...local, second: 0 }; // Copy current local parts\n\n  // If weekend, move to next Monday\n  let isWeekend = targetLocal.weekday === 0 || targetLocal.weekday === 6;\n  if (isWeekend || minutesNow >= workEndMin) {\n    let daysToAdd = 1;\n    if (isWeekend) {\n      // If Saturday (6), add 2 to Monday; Sunday (0), add 1\n      daysToAdd = targetLocal.weekday === 6 ? 2 : 1;\n    }\n    let nextDay = addDaysToLocal(targetLocal, daysToAdd);\n    while (nextDay.weekday === 0 || nextDay.weekday === 6) {\n      nextDay = addDaysToLocal(nextDay, 1);\n    }\n    targetLocal.year = nextDay.year;\n    targetLocal.month = nextDay.month;\n    targetLocal.day = nextDay.day;\n    targetLocal.weekday = nextDay.weekday;\n    // Reset to start of day for random\n    minutesNow = 0;\n  }\n\n  // Set start min: max(current +1 min if in workday, work start)\n  let startMin = Math.max(minutesNow + 1, workStartMin);\n  if (startMin >= workEndMin) {\n    // If no time left today, move to next workday\n    let nextDay = addDaysToLocal(targetLocal, 1);\n    while (nextDay.weekday === 0 || nextDay.weekday === 6) {\n      nextDay = addDaysToLocal(nextDay, 1);\n    }\n    targetLocal.year = nextDay.year;\n    targetLocal.month = nextDay.month;\n    targetLocal.day = nextDay.day;\n    targetLocal.weekday = nextDay.weekday;\n    startMin = workStartMin;\n  }\n\n  // Now pick random in [startMin, workEndMin)\n  const rangeMin = workEndMin - startMin;\n  if (rangeMin <= 0) {\n    throw new Error('Invalid time range');\n  }\n  const randomMinTotal = startMin + Math.floor(Math.random() * rangeMin);\n  targetLocal.hour = Math.floor(randomMinTotal / 60);\n  targetLocal.minute = randomMinTotal % 60;\n\n  // Convert to UTC\n  const nextUtc = localPartsToUtc(targetLocal, tz);\n\n  return nextUtc.toISOString();\n}\n\nconst tz = $('Get a specific business').first().json.timezone || 'America/New_York';\n\nconst scheduledAt = getNextWorkingTimeInTimezone(tz);\n\nreturn { scheduled_at: scheduledAt } ;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        0
      ],
      "id": "b3a579ec-d6dd-4a0b-9ba7-d1f754364352",
      "name": "Time to Schedule call based on Business Timezone Within 24 hours - Mon - Fri",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const prevScheduledAt = new Date($input.first().json.scheduled_at);\n  const newScheduledAt = new Date(prevScheduledAt.getTime() + 5 * 24 * 60 * 60 * 1000); // +7 days\n\n  return {\n    json: {\n      scheduled_at: newScheduledAt.toISOString()\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        0
      ],
      "id": "6a8e2dc5-5ec3-4b1d-8d90-0d3737fa9b2b",
      "name": "Time to Schedule Max Limit of Waiting for Inbound Call 5 days from outbound call time"
    }
  ],
  "connections": {
    "Get Unprocessed Audits Real Time": {
      "main": [
        [
          {
            "node": "Confirm if the Status is Pending of Audit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Confirm if the Status is Pending of Audit": {
      "main": [
        [
          {
            "node": "Get a specific business",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Lead Gen Steps Names": {
      "main": [
        [
          {
            "node": "Time to Schedule call based on Business Timezone Within 24 hours - Mon - Fri",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Creating Steps in Task Groups Table": {
      "main": [
        []
      ]
    },
    "Get a specific business": {
      "main": [
        [
          {
            "node": "Set Lead Gen Steps Names",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Time to Schedule call based on Business Timezone Within 24 hours - Mon - Fri": {
      "main": [
        [
          {
            "node": "Time to Schedule Max Limit of Waiting for Inbound Call 5 days from outbound call time",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Time to Schedule Max Limit of Waiting for Inbound Call 5 days from outbound call time": {
      "main": [
        [
          {
            "node": "Creating Steps in Task Groups Table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "877bbf43-c30e-49f9-91be-a6e5145a4ebf",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-07-11T10:15:21.619Z",
      "updatedAt": "2025-07-11T10:15:21.619Z",
      "role": "workflow:owner",
      "workflowId": "pvwsCL45x2kk2u8Q",
      "projectId": "LuK1n39yspgZn4ID",
      "project": {
        "createdAt": "2025-06-03T10:24:12.778Z",
        "updatedAt": "2025-06-03T11:30:21.622Z",
        "id": "LuK1n39yspgZn4ID",
        "name": "Fuzail Sohail <fuzailsohail40@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "createdAt": "2025-06-03T10:24:12.781Z",
            "updatedAt": "2025-06-03T10:24:12.781Z",
            "userId": "9ba5b413-59b6-4d30-ad4b-75763cd3a374",
            "projectId": "LuK1n39yspgZn4ID",
            "user": {
              "createdAt": "2025-06-03T10:24:12.776Z",
              "updatedAt": "2025-10-27T04:00:00.000Z",
              "id": "9ba5b413-59b6-4d30-ad4b-75763cd3a374",
              "email": "fuzailsohail40@gmail.com",
              "firstName": "Fuzail",
              "lastName": "Sohail",
              "personalizationAnswers": null,
              "settings": {
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "CcHBrELrSsWhXNYT",
                "userActivated": true,
                "userActivatedAt": 1750330808510,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1753277941726
                }
              },
              "disabled": false,
              "mfaEnabled": true,
              "lastActiveAt": "2025-10-27",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [
    {
      "createdAt": "2025-08-14T20:27:52.072Z",
      "updatedAt": "2025-08-14T20:27:52.072Z",
      "id": "CbQQ2nfApBR0i0Ru",
      "name": "TopRatedCoachAI"
    }
  ]
}